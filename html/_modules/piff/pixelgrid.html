
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>piff.pixelgrid &#8212; Piff 0.2.4 documentation</title>
    <link rel="stylesheet" href="../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="nav-item nav-item-0"><a href="../../index.html">Piff 0.2.4 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for piff.pixelgrid</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright (c) 2016 by Mike Jarvis and the other collaborators on GitHub at</span>
<span class="c1"># https://github.com/rmjarvis/Piff  All rights reserved.</span>
<span class="c1">#</span>
<span class="c1"># Piff is free software: Redistribution and use in source and binary forms</span>
<span class="c1"># with or without modification, are permitted provided that the following</span>
<span class="c1"># conditions are met:</span>
<span class="c1">#</span>
<span class="c1"># 1. Redistributions of source code must retain the above copyright notice, this</span>
<span class="c1">#    list of conditions and the disclaimer given in the accompanying LICENSE</span>
<span class="c1">#    file.</span>
<span class="c1"># 2. Redistributions in binary form must reproduce the above copyright notice,</span>
<span class="c1">#    this list of conditions and the disclaimer given in the documentation</span>
<span class="c1">#    and/or other materials provided with the distribution.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">.. module:: pixelmodel</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">galsim</span>

<span class="kn">from</span> <span class="nn">.model</span> <span class="k">import</span> <span class="n">Model</span>
<span class="kn">from</span> <span class="nn">.star</span> <span class="k">import</span> <span class="n">Star</span><span class="p">,</span> <span class="n">StarFit</span>

<div class="viewcode-block" id="PixelGrid"><a class="viewcode-back" href="../../model.html#piff.PixelGrid">[docs]</a><span class="k">class</span> <span class="nc">PixelGrid</span><span class="p">(</span><span class="n">Model</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A PSF modeled as interpolation between a grid of points.</span>

<span class="sd">    The parameters of the model are the values at the grid points, although the constraint</span>
<span class="sd">    for unit flux means that not all grid points are free parameters.  The grid is in uv</span>
<span class="sd">    space, with the pitch and size specified on construction. Optionally a boolean</span>
<span class="sd">    mask array can be passed specifying which tells which grid elements are non-zero.</span>
<span class="sd">    Interpolation will always assume values of zero outside of grid.  Integral of PSF is</span>
<span class="sd">    forced to unity and, optionally, centroid is forced to origin.  As a consequence 1 (or 3)</span>
<span class="sd">    of the PSF pixel values will be missing from the parameter vector as they are determined</span>
<span class="sd">    by the flux (and centroid) constraints. And there is more covariance between pixel values.</span>

<span class="sd">    PixelGrid also needs an PixelInterpolant on construction to specify how to determine</span>
<span class="sd">    values between grid points.</span>

<span class="sd">    Stellar data is assumed either to be in flux units (with default sb=False), such that</span>
<span class="sd">    flux is defined as sum of pixel values; or in surface brightness units (sb=True), such</span>
<span class="sd">    that flux is (sum of pixels)*(pixel area).  Internally the sb convention is used.</span>

<span class="sd">    Convention of this code is that coordinates are (u,v).  All 2d forms of the PSF use</span>
<span class="sd">    this indexing order also.  StarData classes can use whatever they want, we only</span>
<span class="sd">    access them via 1d arrays.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">interp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">start_sigma</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span>
                 <span class="n">force_model_center</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">degenerate</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Constructor for PixelGrid defines the PSF pitch, size, and interpolator.</span>

<span class="sd">        :param scale:       Pixel scale of the PSF model (in arcsec)</span>
<span class="sd">        :param size:        Number of pixels on each side of square grid.</span>
<span class="sd">        :param interp:      An Interpolator to be used [default: Lanczos(3)]</span>
<span class="sd">        :param mask:        Optional square boolean 2d array, True where we want a non-zero value</span>
<span class="sd">                            [default: None]</span>
<span class="sd">        :param start_sigma: sigma of a 2d Gaussian installed as 1st guess for all stars</span>
<span class="sd">                            [default: 1.]</span>
<span class="sd">        :param force_model_center: If True, PSF model centroid is fixed at origin and</span>
<span class="sd">                            PSF fitting will marginalize over stellar position.  If False, stellar</span>
<span class="sd">                            position is fixed at input value and the fitted PSF may be off-center.</span>
<span class="sd">                            [default: True]</span>
<span class="sd">        :param degenerate:  Is it possible that individual stars give degenerate PSF sol&#39;n?</span>
<span class="sd">                            If False, it runs faster, but fails on degeneracies. [default: True]</span>
<span class="sd">        :param logger:      A logger object for logging debug info. [default: None]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">LoggerWrapper</span><span class="p">(</span><span class="n">logger</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Building Pixel model with the following parameters:&quot;</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;scale = </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span><span class="n">scale</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;size = </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span><span class="n">size</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;interp = </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span><span class="n">interp</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;mask = </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span><span class="n">mask</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;start_sigma = </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span><span class="n">start_sigma</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;force_model_center = </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span><span class="n">force_model_center</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;degenerate = </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span><span class="n">degenerate</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">du</span> <span class="o">=</span> <span class="n">scale</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pixel_area</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">du</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">du</span>
        <span class="k">if</span> <span class="n">interp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">interp</span> <span class="o">=</span> <span class="n">Lanczos</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interp</span> <span class="o">=</span> <span class="n">interp</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_force_model_center</span> <span class="o">=</span> <span class="n">force_model_center</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_degenerate</span> <span class="o">=</span> <span class="n">degenerate</span>

        <span class="c1"># These are the kwargs that can be serialized easily.</span>
        <span class="c1"># TODO: Add interp to this, so it can be specified in the yaml file and read/written.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;scale&#39;</span> <span class="p">:</span> <span class="n">scale</span><span class="p">,</span>
            <span class="s1">&#39;size&#39;</span> <span class="p">:</span> <span class="n">size</span><span class="p">,</span>
            <span class="s1">&#39;start_sigma&#39;</span> <span class="p">:</span> <span class="n">start_sigma</span><span class="p">,</span>
            <span class="s1">&#39;force_model_center&#39;</span> <span class="p">:</span> <span class="n">force_model_center</span><span class="p">,</span>
            <span class="s1">&#39;degenerate&#39;</span> <span class="p">:</span> <span class="n">degenerate</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">size</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Non-positive PixelGrid size </span><span class="si">{:d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">size</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span> <span class="p">(</span><span class="n">size</span><span class="p">,</span><span class="n">size</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">size</span><span class="p">,</span><span class="n">size</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Shape of input mask does not match size </span><span class="si">{:d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">size</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">mask</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="o">.</span><span class="n">shape</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nparams</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nparams</span> <span class="o">-=</span><span class="mi">1</span>  <span class="c1"># The flux constraint will remove 1 degree of freedom</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_constraints</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_force_model_center</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_nparams</span> <span class="o">-=</span> <span class="mi">2</span> <span class="c1"># Centroid constraint will remove 2 more degrees of freedom</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_constraints</span> <span class="o">+=</span> <span class="mi">2</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;nparams = </span><span class="si">%d</span><span class="s2">, constraints = </span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_nparams</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constraints</span><span class="p">)</span>

        <span class="c1"># Now we need to make a 2d array whose entries are the indices of</span>
        <span class="c1"># each pixel in the 1d parameter array.  We will put the central</span>
        <span class="c1"># pixels (and first to top &amp; right) at the front of the array</span>
        <span class="c1"># because we will be chopping these off when we enforce the</span>
        <span class="c1"># flux (and center) conditions on the PSF.</span>
        <span class="c1"># In this array, a negative entry is a pixel that is not being</span>
        <span class="c1"># fit (and always assumed to be zero, for interpolation purposes).</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constraints</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_origin</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ny</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nx</span><span class="o">//</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_origin</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Not happy with central PSF pixel being masked&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_indices</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_origin</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>    <span class="c1"># Central pixel for flux constraint</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_force_model_center</span><span class="p">:</span>
            <span class="n">u1</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_origin</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_origin</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">v1</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_origin</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>   <span class="bp">self</span><span class="o">.</span><span class="n">_origin</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">[</span><span class="n">u1</span><span class="p">]</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">[</span><span class="n">v1</span><span class="p">]):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Not happy with near-central PSF pixels being masked&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_indices</span><span class="p">[</span><span class="n">u1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_indices</span><span class="p">[</span><span class="n">v1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="n">free_param</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indices</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constraints</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_indices</span><span class="p">[</span><span class="n">free_param</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_constraints</span><span class="p">,</span>
                                              <span class="bp">self</span><span class="o">.</span><span class="n">_constraints</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">_nparams</span><span class="p">,</span>
                                              <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

        <span class="c1"># Next job is to create the flux/center constraint conditions.</span>
        <span class="c1"># ??? Could have some type of window function here, for now just</span>
        <span class="c1"># ??? using unweighted flux &amp; centroid</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_constraints</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constraints</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nparams</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_constraints</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">=</span> <span class="mf">1.</span>
        <span class="n">B</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">pixel_area</span>  <span class="c1"># That&#39;s the flux constraint - sum(pixels) * pixel_area=1</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_force_model_center</span><span class="p">:</span>
            <span class="c1"># Generate linear center constraints too</span>
            <span class="n">delta_u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_origin</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_origin</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">,:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_1dFrom2d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_indices</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span> \
                                    <span class="o">*</span> <span class="n">delta_u</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span>
            <span class="n">B</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>
            <span class="n">delta_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_origin</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_origin</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">A</span><span class="p">[</span><span class="mi">2</span><span class="p">,:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_1dFrom2d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_indices</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
                                    <span class="o">*</span> <span class="n">delta_v</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,:])</span>
            <span class="n">B</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>

        <span class="n">ainv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">A</span><span class="p">[:,:</span><span class="bp">self</span><span class="o">.</span><span class="n">_constraints</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">ainv</span><span class="p">,</span> <span class="n">A</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constraints</span><span class="p">:])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">ainv</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
        <span class="c1"># Now our constraints are that p0 = _b - _a * p1 where p0 are the (1 or 3) constrained</span>
        <span class="c1"># pixel values and p1 are the remaining free ones.</span>
        <span class="c1"># For later convenience, add some columns of zeros to _a so it can multiply</span>
        <span class="c1"># into arrays containing flux (and center) shift</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">_constraints</span><span class="p">),</span>
                        <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">tmp</span><span class="p">[:,:</span><span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_a</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_a</span> <span class="o">=</span> <span class="n">tmp</span>

        <span class="c1"># Now create a parameter array for a Gaussian that will be used to initialize new stars</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_origin</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_origin</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">du</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_origin</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_origin</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">du</span>
        <span class="n">rsq</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span><span class="o">*</span><span class="n">u</span><span class="p">)[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">v</span><span class="o">*</span><span class="n">v</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,:]</span>
        <span class="n">gauss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">rsq</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.</span><span class="o">*</span> <span class="n">start_sigma</span> <span class="o">*</span> <span class="n">start_sigma</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_force_model_center</span><span class="p">:</span>
            <span class="c1"># If we are enforcing centering then we need to have symmetry about origin</span>
            <span class="c1"># This means if PSF has even number of dimensions, need to null the hanger-on</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">%</span><span class="mi">2</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">gauss</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">=</span> <span class="mf">0.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">%</span><span class="mi">2</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">gauss</span><span class="p">[</span><span class="mi">1</span><span class="p">,:]</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_1dFrom2d</span><span class="p">(</span><span class="n">gauss</span><span class="p">)</span>
        <span class="c1"># Renormalize to get unity flux</span>
        <span class="n">params</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">params</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">pixel_area</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initial_params</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_constraints</span><span class="p">:]</span>

        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">_1dFrom2d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in2d</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Make a 1d array from a 2d array, using the model&#39;s</span>
<span class="sd">        mapping from the 2d psf grid to the 1d parameter array.</span>

<span class="sd">        :param in2d:    A 2d array matching the PSFs sample grid</span>

<span class="sd">        :returns:       A 1d array of the length of number of grid points in use</span>

<span class="sd">        :returns  None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">out1d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_constraints</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nparams</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">in2d</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">out1d</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_indices</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">]]</span> <span class="o">=</span> <span class="n">in2d</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">out1d</span>

    <span class="k">def</span> <span class="nf">_2dFrom1d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in1d</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Make a 2d array of the PSF from a 1d list of grid points, using the model&#39;s</span>
<span class="sd">        mapping from the 2d psf to the 1d parameter array.</span>

<span class="sd">        :param in1d:    A 1d array of values for PSF grid points in use</span>

<span class="sd">        :returns:       A 2d array representing the PSF, with zeros for grid points not in mask.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="n">in1d</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="c1"># The i array is the input array supplemented by a zero for pixels outside of mask</span>
        <span class="n">i</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">in1d</span>
        <span class="c1"># Now index the 1d array by the index array altered to point to the extra zero element</span>
        <span class="c1"># where the mask is False:</span>
        <span class="k">return</span> <span class="n">i</span><span class="p">[</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indices</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">_indexFromPsfxy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">psfx</span><span class="p">,</span> <span class="n">psfy</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Turn arrays of coordinates of the PSF array into a single same-shape</span>
<span class="sd">        array of indices into a 1d parameter vector.  The index is &lt;0 wherever</span>
<span class="sd">        the psf x,y values were outside the PSF mask.</span>

<span class="sd">        :param psfx:  array (any shape) of integer x displacements from origin</span>
<span class="sd">        of the PSF grid</span>
<span class="sd">        :param psfy:  array of integer y locations in PSF grid</span>

<span class="sd">        :returns: same shape array, filled with indices into 1d array</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">psfx</span><span class="o">.</span><span class="n">shape</span><span class="o">==</span><span class="n">psfy</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;psfx and psfy arrays are not same shape&quot;</span><span class="p">)</span>

        <span class="c1"># First, shift psfy, psfx to reference a 0-indexed array</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">psfy</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_origin</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">psfx</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_origin</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># Mark references to invalid pixels with nopsf array</span>
        <span class="c1"># First note which pixels are referenced outside of grid:</span>
        <span class="n">nopsf</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">y</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ny</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nx</span><span class="p">)</span>
        <span class="c1"># Set them to reference pixel 0</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">nopsf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">nopsf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="c1"># Then read all indices, setting invalid ones to -1</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">nopsf</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indices</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_fullPsf1d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">star</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Using stored PSF parameters, create full 1d array of PSF grid</span>
<span class="sd">        point values by applying the flux (and center) constraints to generate</span>
<span class="sd">        the dependent values</span>

<span class="sd">        :param star:  A Star instance whose parameters to use</span>

<span class="sd">        :returns: 1d array of all PSF values at grid points in mask</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">constrained</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="p">[:,:</span><span class="bp">self</span><span class="o">.</span><span class="n">_nparams</span><span class="p">],</span> <span class="n">star</span><span class="o">.</span><span class="n">fit</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">constrained</span><span class="p">,</span> <span class="n">star</span><span class="o">.</span><span class="n">fit</span><span class="o">.</span><span class="n">params</span><span class="p">))</span>

<div class="viewcode-block" id="PixelGrid.fillPSF"><a class="viewcode-back" href="../../model.html#piff.PixelGrid.fillPSF">[docs]</a>    <span class="k">def</span> <span class="nf">fillPSF</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">star</span><span class="p">,</span> <span class="n">in2d</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Initialize the PSF for a star from a given 2d uv-plane array.</span>
<span class="sd">        Sets elements outside the mask to zero, renormalizes to enforce flux</span>
<span class="sd">        condition, and checks centering condition if force_model_center=True</span>

<span class="sd">        :param star:    A Star instance to initialize</span>
<span class="sd">        :param in2d:    2d input array matching the PSF uv-plane grid</span>

<span class="sd">        :returns: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_1dFrom2d</span><span class="p">(</span><span class="n">in2d</span><span class="p">)</span>

        <span class="c1"># Renormalize to get unity flux</span>
        <span class="n">params</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">params</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">pixel_area</span>
        <span class="c1"># ??? check centering ???</span>

        <span class="n">star</span><span class="o">.</span><span class="n">fit</span><span class="o">.</span><span class="n">params</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_constraints</span><span class="p">:]</span>  <span class="c1"># Omit the constrained pixels</span></div>

<div class="viewcode-block" id="PixelGrid.initialize"><a class="viewcode-back" href="../../model.html#piff.PixelGrid.initialize">[docs]</a>    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">star</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a star to work with the current model.</span>

<span class="sd">        :param star:    A Star instance with the raw data.</span>
<span class="sd">        :param mask:    If True, set data.weight to zero at pixels that are outside</span>
<span class="sd">                        the range of the model.</span>
<span class="sd">        :param logger:  A logger object for logging debug info. [default: None]</span>

<span class="sd">        :returns: a star instance with the appropriate initial fit values</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">fit</span> <span class="o">=</span> <span class="n">StarFit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_initial_params</span><span class="p">,</span> <span class="n">star</span><span class="o">.</span><span class="n">fit</span><span class="o">.</span><span class="n">flux</span><span class="p">,</span> <span class="n">star</span><span class="o">.</span><span class="n">fit</span><span class="o">.</span><span class="n">center</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mask</span><span class="p">:</span>
            <span class="c1"># Null weight at pixels where interpolation coefficients</span>
            <span class="c1"># come up short of specified fraction of the total kernel</span>
            <span class="n">required_kernel_fraction</span> <span class="o">=</span> <span class="mf">0.7</span>

            <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">star</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">getDataVector</span><span class="p">()</span>
            <span class="c1"># Subtract star.fit.center from u, v:</span>
            <span class="n">u</span> <span class="o">-=</span> <span class="n">fit</span><span class="o">.</span><span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">v</span> <span class="o">-=</span> <span class="n">fit</span><span class="o">.</span><span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">coeffs</span><span class="p">,</span> <span class="n">psfx</span><span class="p">,</span> <span class="n">psfy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">u</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">du</span><span class="p">,</span> <span class="n">v</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">du</span><span class="p">)</span>
            <span class="c1"># Turn the (psfx,psfy) coordinates into an index into 1d parameter vector.</span>
            <span class="n">index1d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indexFromPsfxy</span><span class="p">(</span><span class="n">psfx</span><span class="p">,</span> <span class="n">psfy</span><span class="p">)</span>
            <span class="c1"># All invalid pixel references now have negative index;</span>
            <span class="c1"># Null the coefficients for such pixels</span>
            <span class="n">coeffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">index1d</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">coeffs</span><span class="p">)</span>
            <span class="n">use</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">coeffs</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">required_kernel_fraction</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">star</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">maskPixels</span><span class="p">(</span><span class="n">use</span><span class="p">)</span>
        <span class="n">star</span> <span class="o">=</span> <span class="n">Star</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">fit</span><span class="p">)</span>
        <span class="c1"># Update the flux to something close to right.</span>
        <span class="n">star</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reflux</span><span class="p">(</span><span class="n">star</span><span class="p">,</span> <span class="n">fit_center</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">star</span></div>

<div class="viewcode-block" id="PixelGrid.fit"><a class="viewcode-back" href="../../model.html#piff.PixelGrid.fit">[docs]</a>    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">star</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Fit the Model to the star&#39;s data to yield iterative improvement on</span>
<span class="sd">        its PSF parameters, their uncertainties, and flux (and center, if free).</span>

<span class="sd">        :param star:    A Star instance</span>
<span class="sd">        :param logger:  A logger object for logging debug info. [default: None]</span>

<span class="sd">        :returns: a new Star instance with updated fit information</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">star1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chisq</span><span class="p">(</span><span class="n">star</span><span class="p">)</span>  <span class="c1"># Get chisq Taylor expansion for linearized model</span>
        <span class="c1">### Check for non-pos-def</span>
        <span class="c1">###S = np.linalg.svd(star1.fit.alpha,compute_uv=False)</span>
        <span class="c1">###print(&quot;  .in fit(), min SV:&quot;,np.min(S))###</span>
        <span class="c1">###U,S,Vt = np.linalg.svd(star1.fit.alpha,compute_uv=True)</span>
        <span class="c1">###print(&quot;  ..in fit(), min SV:&quot;,np.min(S))###</span>

        <span class="c1"># star1 has marginalized over flux (&amp; center, if free), and updated these</span>
        <span class="c1"># for best linearized fit at the input parameter values.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_degenerate</span><span class="p">:</span>
            <span class="c1"># Do SVD and retain</span>
            <span class="c1"># input values for degenerate parameter combinations</span>
            <span class="c1"># U,S,Vt = np.linalg.svd(star1.fit.alpha)</span>
            <span class="n">S</span><span class="p">,</span><span class="n">U</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">star1</span><span class="o">.</span><span class="n">fit</span><span class="o">.</span><span class="n">alpha</span><span class="p">)</span>
            <span class="c1"># Invert, while zeroing small elements of S.</span>
            <span class="c1"># &quot;Small&quot; will be taken to be causing a small chisq change</span>
            <span class="c1"># when corresponding PSF component changes by the full flux of PSF</span>
            <span class="n">small</span> <span class="o">=</span> <span class="mf">0.2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">pixel_area</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">pixel_area</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">S</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">small</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;negative: &quot;</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">S</span><span class="p">),</span><span class="s2">&quot;small:&quot;</span><span class="p">,</span><span class="n">small</span><span class="p">)</span><span class="c1">###</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Negative singular value in alpha matrix&quot;</span><span class="p">)</span>
            <span class="c1"># Leave values that are close to zero equal to zero in inverse.</span>
            <span class="n">nonzero</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">S</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">small</span>
            <span class="n">invs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
            <span class="n">invs</span><span class="p">[</span><span class="n">nonzero</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="n">S</span><span class="p">[</span><span class="n">nonzero</span><span class="p">]</span>

            <span class="c1">###print(&#39;S/zero:&#39;,S.shape,np.count_nonzero(np.abs(S)&lt;=small),&#39;small=&#39;,small) ###</span>
            <span class="c1">###print(&#39; &#39;,np.max(S[np.abs(S)&lt;=small]),np.min(S[np.abs(S)&gt;small])) ##</span>
            <span class="c1"># answer = V * S^{-1} * U^T * beta</span>
            <span class="c1"># dparam = np.dot(Vt.T, invs * np.dot(U.T,star1.fit.beta))</span>
            <span class="n">dparam</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="n">invs</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">U</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">star1</span><span class="o">.</span><span class="n">fit</span><span class="o">.</span><span class="n">beta</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># If it is known there are no degeneracies, we can skip SVD</span>
            <span class="n">dparam</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">star1</span><span class="o">.</span><span class="n">fit</span><span class="o">.</span><span class="n">alpha</span><span class="p">,</span> <span class="n">star1</span><span class="o">.</span><span class="n">fit</span><span class="o">.</span><span class="n">beta</span><span class="p">)</span>
            <span class="c1"># ??? dparam = scipy.linalg.solve(alpha, beta, sym_pos=True) would be faster</span>
        <span class="c1"># Create new StarFit, update the chisq value.  Note no beta is returned as</span>
        <span class="c1"># the quadratic Taylor expansion was about the old parameters, not these.</span>
        <span class="n">starfit2</span> <span class="o">=</span> <span class="n">StarFit</span><span class="p">(</span><span class="n">star1</span><span class="o">.</span><span class="n">fit</span><span class="o">.</span><span class="n">params</span> <span class="o">+</span> <span class="n">dparam</span><span class="p">,</span>
                           <span class="n">flux</span> <span class="o">=</span> <span class="n">star1</span><span class="o">.</span><span class="n">fit</span><span class="o">.</span><span class="n">flux</span><span class="p">,</span>
                           <span class="n">center</span> <span class="o">=</span> <span class="n">star1</span><span class="o">.</span><span class="n">fit</span><span class="o">.</span><span class="n">center</span><span class="p">,</span>
                           <span class="n">alpha</span> <span class="o">=</span> <span class="n">star1</span><span class="o">.</span><span class="n">fit</span><span class="o">.</span><span class="n">alpha</span><span class="p">,</span>  <span class="c1"># Inverse covariance matrix</span>
                           <span class="n">chisq</span> <span class="o">=</span> <span class="n">star1</span><span class="o">.</span><span class="n">fit</span><span class="o">.</span><span class="n">chisq</span> \
                                   <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">dparam</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">star1</span><span class="o">.</span><span class="n">fit</span><span class="o">.</span><span class="n">alpha</span><span class="p">,</span> <span class="n">dparam</span><span class="p">))</span> \
                                   <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">star1</span><span class="o">.</span><span class="n">fit</span><span class="o">.</span><span class="n">beta</span><span class="p">,</span> <span class="n">dparam</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">Star</span><span class="p">(</span><span class="n">star1</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">starfit2</span><span class="p">)</span></div>

<div class="viewcode-block" id="PixelGrid.chisq"><a class="viewcode-back" href="../../model.html#piff.PixelGrid.chisq">[docs]</a>    <span class="k">def</span> <span class="nf">chisq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">star</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate dependence of chi^2 = -2 log L(D|p) on PSF parameters for single star.</span>
<span class="sd">        as a quadratic form chi^2 = dp^T*alpha*dp - 2*beta*dp + chisq,</span>
<span class="sd">        where dp is the *shift* from current parameter values.  Marginalization over</span>
<span class="sd">        flux (and center, if free) should be done by this routine. Returned Star</span>
<span class="sd">        instance has the resultant alpha, beta, chisq, flux, center) attributes,</span>
<span class="sd">        but params vector has not have been updated yet (could be degenerate).</span>

<span class="sd">        :param star:    A Star instance</span>
<span class="sd">        :param logger:  A logger object for logging debug info. [default: None]</span>

<span class="sd">        :returns: a new Star instance with updated StarFit</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Start by getting all interpolation coefficients for all observed points</span>
        <span class="n">data</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">star</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">getDataVector</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">star</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">values_are_sb</span><span class="p">:</span>
            <span class="c1"># If the images are flux instead of surface brightness, convert</span>
            <span class="c1"># them into SB</span>
            <span class="n">star_pix_area</span> <span class="o">=</span> <span class="n">star</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">pixel_area</span>
            <span class="n">data</span> <span class="o">/=</span> <span class="n">star_pix_area</span>
            <span class="n">weight</span> <span class="o">*=</span> <span class="n">star_pix_area</span><span class="o">*</span><span class="n">star_pix_area</span>

        <span class="c1"># Subtract star.fit.center from u, v:</span>
        <span class="n">u</span> <span class="o">-=</span> <span class="n">star</span><span class="o">.</span><span class="n">fit</span><span class="o">.</span><span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">v</span> <span class="o">-=</span> <span class="n">star</span><span class="o">.</span><span class="n">fit</span><span class="o">.</span><span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_force_model_center</span><span class="p">:</span>
            <span class="n">coeffs</span><span class="p">,</span> <span class="n">dcdu</span><span class="p">,</span> <span class="n">dcdv</span><span class="p">,</span> <span class="n">psfx</span><span class="p">,</span> <span class="n">psfy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interp</span><span class="o">.</span><span class="n">derivatives</span><span class="p">(</span><span class="n">u</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">du</span><span class="p">,</span> <span class="n">v</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">du</span><span class="p">)</span>
            <span class="n">dcdu</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">du</span>
            <span class="n">dcdv</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">du</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">coeffs</span><span class="p">,</span> <span class="n">psfx</span><span class="p">,</span> <span class="n">psfy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">u</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">du</span><span class="p">,</span> <span class="n">v</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">du</span><span class="p">)</span>

        <span class="c1"># Turn the (psfy,psfx) coordinates into an index into 1d parameter vector.</span>
        <span class="n">index1d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indexFromPsfxy</span><span class="p">(</span><span class="n">psfx</span><span class="p">,</span> <span class="n">psfy</span><span class="p">)</span>
        <span class="c1"># All invalid pixel references now have negative index; record and set to zero</span>
        <span class="n">nopsf</span> <span class="o">=</span> <span class="n">index1d</span> <span class="o">&lt;</span> <span class="mi">0</span>
        <span class="n">index1d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">nopsf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">index1d</span><span class="p">)</span>
        <span class="c1"># And null the coefficients for such pixels</span>
        <span class="n">coeffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">nopsf</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">coeffs</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_force_model_center</span><span class="p">:</span>
            <span class="n">dcdu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">nopsf</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">dcdu</span><span class="p">)</span>
            <span class="n">dcdv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">nopsf</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">dcdv</span><span class="p">)</span>

        <span class="c1"># Multiply kernel (and derivs) by current PSF element values</span>
        <span class="c1"># to get current estimates</span>
        <span class="n">pvals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fullPsf1d</span><span class="p">(</span><span class="n">star</span><span class="p">)[</span><span class="n">index1d</span><span class="p">]</span>
        <span class="n">mod</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">coeffs</span><span class="o">*</span><span class="n">pvals</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_force_model_center</span><span class="p">:</span>
            <span class="n">dmdu</span> <span class="o">=</span> <span class="n">star</span><span class="o">.</span><span class="n">fit</span><span class="o">.</span><span class="n">flux</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dcdu</span><span class="o">*</span><span class="n">pvals</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">dmdv</span> <span class="o">=</span> <span class="n">star</span><span class="o">.</span><span class="n">fit</span><span class="o">.</span><span class="n">flux</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dcdv</span><span class="o">*</span><span class="n">pvals</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">resid</span> <span class="o">=</span> <span class="n">data</span> <span class="o">-</span> <span class="n">mod</span><span class="o">*</span><span class="n">star</span><span class="o">.</span><span class="n">fit</span><span class="o">.</span><span class="n">flux</span>

        <span class="c1"># Now begin construction of alpha/beta/chisq that give</span>
        <span class="c1"># chisq vs linearized model.</span>
        <span class="n">rw</span> <span class="o">=</span> <span class="n">resid</span> <span class="o">*</span> <span class="n">weight</span>
        <span class="n">chisq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">resid</span> <span class="o">*</span> <span class="n">rw</span><span class="p">)</span>

        <span class="c1"># To begin with, we build alpha and beta over all PSF points</span>
        <span class="c1"># within mask, *and* the flux (and center) shifts.  Then</span>
        <span class="c1"># will eliminate the constrained PSF points, and then</span>
        <span class="c1"># marginalize over the flux (and center).</span>

        <span class="c1"># Augment the coeffs and index1d vectors with extra column(s)</span>
        <span class="c1"># for the shift in flux (and center), so it will be</span>
        <span class="c1"># the derivative of model w.r.t. augmented parameter set</span>
        <span class="n">derivs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="n">coeffs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">coeffs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">_constraints</span><span class="p">),</span>
                           <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="n">index1d</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">index1d</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">_constraints</span><span class="p">),</span>
                            <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">derivs</span><span class="p">[:,</span> <span class="p">:</span><span class="n">coeffs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">star</span><span class="o">.</span><span class="n">fit</span><span class="o">.</span><span class="n">flux</span> <span class="o">*</span> <span class="n">coeffs</span>  <span class="c1">#derivs wrt PSF elements</span>
        <span class="n">indices</span><span class="p">[:,:</span><span class="n">index1d</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">index1d</span>

        <span class="c1"># Add derivs wrt flux</span>
        <span class="n">derivs</span><span class="p">[:,</span><span class="n">coeffs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">mod</span>
        <span class="n">dflux_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nparams</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constraints</span>
        <span class="n">indices</span><span class="p">[:,</span><span class="n">coeffs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">dflux_index</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_force_model_center</span><span class="p">:</span>
            <span class="c1"># Derivs w.r.t. center shift:</span>
            <span class="n">derivs</span><span class="p">[:,</span><span class="n">coeffs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">dmdu</span>
            <span class="n">derivs</span><span class="p">[:,</span><span class="n">coeffs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">dmdv</span>
            <span class="n">indices</span><span class="p">[:,</span><span class="n">coeffs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">dflux_index</span><span class="o">+</span><span class="mi">1</span>
            <span class="n">indices</span><span class="p">[:,</span><span class="n">coeffs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">dflux_index</span><span class="o">+</span><span class="mi">2</span>

        <span class="c1"># Accumulate alpha and beta point by point.  I don&#39;t</span>
        <span class="c1"># know how to do it purely with numpy calls instead of a loop over data points</span>
        <span class="n">nderivs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nparams</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_constraints</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nderivs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="n">nderivs</span><span class="p">,</span><span class="n">nderivs</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)):</span>
            <span class="n">ii</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span>
            <span class="n">cc</span> <span class="o">=</span> <span class="n">derivs</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span>
            <span class="c1"># beta_j += resid_i * weight_i * coeff_{ij}</span>
            <span class="n">beta</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">+=</span> <span class="n">rw</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">cc</span>
            <span class="c1"># alpha_jk += weight_i * coeff_ij * coeff_ik</span>
            <span class="n">dalpha</span> <span class="o">=</span> <span class="n">cc</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,:]</span><span class="o">*</span><span class="n">cc</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">weight</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">iouter</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">ii</span><span class="p">,</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ii</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">ii</span><span class="p">)))</span>
            <span class="n">alpha</span><span class="p">[</span><span class="n">iouter</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">iouter</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">flatten</span><span class="p">()]</span> <span class="o">+=</span> <span class="n">dalpha</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

        <span class="c1"># Next we eliminate the first _constraints PSF values from the parameters</span>
        <span class="c1"># using the linear constraints that dp0 = - _a * dp1</span>
        <span class="n">s0</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constraints</span><span class="p">)</span>  <span class="c1"># parameters to eliminate</span>
        <span class="n">s1</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_constraints</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>  <span class="c1"># parameters to keep</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="n">beta</span><span class="p">[</span><span class="n">s1</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">beta</span><span class="p">[</span><span class="n">s0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">alpha</span><span class="p">[</span><span class="n">s1</span><span class="p">,</span><span class="n">s1</span><span class="p">]</span> \
          <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">alpha</span><span class="p">[</span><span class="n">s0</span><span class="p">,</span><span class="n">s1</span><span class="p">])</span> \
          <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">alpha</span><span class="p">[</span><span class="n">s1</span><span class="p">,</span><span class="n">s0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="p">)</span> \
          <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">alpha</span><span class="p">[</span><span class="n">s0</span><span class="p">,</span><span class="n">s0</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="p">))</span>

        <span class="c1"># Now we marginalize over the flux (and center). These shifts are at</span>
        <span class="c1"># the back end of the parameter array.</span>
        <span class="c1"># But first we need to apply a prior to the shift of flux (and center)</span>
        <span class="c1"># to avoid numerical instabilities when these are degenerate because of</span>
        <span class="c1"># missing pixel data or otherwise unspecified PSF</span>
        <span class="c1"># ??? make these properties of the Model???</span>
        <span class="n">fractional_flux_prior</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="c1"># prior of 50% on pre-existing flux ???</span>
        <span class="n">center_shift_prior</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">du</span> <span class="c1">#prior of 0.5 uv-plane pixels ???</span>
        <span class="n">alpha</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_nparams</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nparams</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">fractional_flux_prior</span><span class="o">*</span><span class="n">star</span><span class="o">.</span><span class="n">fit</span><span class="o">.</span><span class="n">flux</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mf">2.</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_force_model_center</span><span class="p">:</span>
            <span class="n">alpha</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_nparams</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nparams</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">center_shift_prior</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mf">2.</span><span class="p">)</span>
            <span class="n">alpha</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_nparams</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nparams</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">center_shift_prior</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mf">2.</span><span class="p">)</span>

        <span class="n">s0</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nparams</span><span class="p">)</span>  <span class="c1"># parameters to keep</span>
        <span class="n">s1</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nparams</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>  <span class="c1"># parameters to marginalize</span>
        <span class="n">a11inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">alpha</span><span class="p">[</span><span class="n">s1</span><span class="p">,</span><span class="n">s1</span><span class="p">])</span>
        <span class="c1"># Calculate shift in flux - ??? Note that this is the solution for shift</span>
        <span class="c1"># when PSF parameters do *not* move; so if we subsequently update</span>
        <span class="c1"># the PSF params, we miss shifts due to covariances between flux and PSF.</span>

        <span class="n">df</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a11inv</span><span class="p">,</span> <span class="n">beta</span><span class="p">[</span><span class="n">s1</span><span class="p">])</span>
        <span class="n">outflux</span> <span class="o">=</span> <span class="n">star</span><span class="o">.</span><span class="n">fit</span><span class="o">.</span><span class="n">flux</span> <span class="o">+</span> <span class="n">df</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_force_model_center</span><span class="p">:</span>
            <span class="n">outcenter</span> <span class="o">=</span> <span class="p">(</span><span class="n">star</span><span class="o">.</span><span class="n">fit</span><span class="o">.</span><span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">df</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                         <span class="n">star</span><span class="o">.</span><span class="n">fit</span><span class="o">.</span><span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">df</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">outcenter</span> <span class="o">=</span> <span class="n">star</span><span class="o">.</span><span class="n">fit</span><span class="o">.</span><span class="n">center</span>

        <span class="c1"># Now get the final alpha, beta, chisq for the remaining PSF params</span>
        <span class="n">outchisq</span> <span class="o">=</span> <span class="n">chisq</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">beta</span><span class="p">[</span><span class="n">s1</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a11inv</span><span class="p">,</span> <span class="n">beta</span><span class="p">[</span><span class="n">s1</span><span class="p">]))</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a11inv</span><span class="p">,</span> <span class="n">alpha</span><span class="p">[</span><span class="n">s1</span><span class="p">,</span><span class="n">s0</span><span class="p">])</span>
        <span class="n">outbeta</span> <span class="o">=</span> <span class="n">beta</span><span class="p">[</span><span class="n">s0</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">beta</span><span class="p">[</span><span class="n">s1</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">tmp</span><span class="p">)</span>
        <span class="n">outalpha</span> <span class="o">=</span> <span class="n">alpha</span><span class="p">[</span><span class="n">s0</span><span class="p">,</span><span class="n">s0</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">alpha</span><span class="p">[</span><span class="n">s0</span><span class="p">,</span><span class="n">s1</span><span class="p">],</span><span class="n">tmp</span><span class="p">)</span>

        <span class="n">outfit</span> <span class="o">=</span> <span class="n">StarFit</span><span class="p">(</span><span class="n">star</span><span class="o">.</span><span class="n">fit</span><span class="o">.</span><span class="n">params</span><span class="p">,</span>
                         <span class="n">flux</span> <span class="o">=</span> <span class="n">outflux</span><span class="p">,</span>
                         <span class="n">center</span> <span class="o">=</span> <span class="n">outcenter</span><span class="p">,</span>
                         <span class="n">chisq</span> <span class="o">=</span> <span class="n">outchisq</span><span class="p">,</span>
                         <span class="n">dof</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nparams</span><span class="p">,</span>
                         <span class="n">alpha</span> <span class="o">=</span> <span class="n">outalpha</span><span class="p">,</span>
                         <span class="n">beta</span> <span class="o">=</span> <span class="n">outbeta</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">Star</span><span class="p">(</span><span class="n">star</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">outfit</span><span class="p">)</span></div>

<div class="viewcode-block" id="PixelGrid.draw"><a class="viewcode-back" href="../../model.html#piff.PixelGrid.draw">[docs]</a>    <span class="k">def</span> <span class="nf">draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">star</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create new Star instance that has StarData filled with a rendering</span>
<span class="sd">        of the PSF specified by the current StarFit parameters, flux, and center.</span>
<span class="sd">        Coordinate mapping of the current StarData is assumed.</span>

<span class="sd">        :param star:   A Star instance</span>

<span class="sd">        :returns:      New Star instance with rendered PSF in StarData</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Start by getting all interpolation coefficients for all observed points</span>
        <span class="n">data</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">star</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">getDataVector</span><span class="p">(</span><span class="n">include_zero_weight</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># Subtract star.fit.center from u, v</span>
        <span class="n">u</span> <span class="o">-=</span> <span class="n">star</span><span class="o">.</span><span class="n">fit</span><span class="o">.</span><span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">v</span> <span class="o">-=</span> <span class="n">star</span><span class="o">.</span><span class="n">fit</span><span class="o">.</span><span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">coeffs</span><span class="p">,</span> <span class="n">psfx</span><span class="p">,</span> <span class="n">psfy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">u</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">du</span><span class="p">,</span> <span class="n">v</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">du</span><span class="p">)</span>
        <span class="c1"># Turn the (psfy,psfx) coordinates into an index into 1d parameter vector.</span>
        <span class="n">index1d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indexFromPsfxy</span><span class="p">(</span><span class="n">psfx</span><span class="p">,</span> <span class="n">psfy</span><span class="p">)</span>
        <span class="c1"># All invalid pixel references now have negative index; record and set to zero</span>
        <span class="n">nopsf</span> <span class="o">=</span> <span class="n">index1d</span> <span class="o">&lt;</span> <span class="mi">0</span>
        <span class="n">index1d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">nopsf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">index1d</span><span class="p">)</span>
        <span class="c1"># And null the coefficients for such pixels</span>
        <span class="n">coeffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">nopsf</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">coeffs</span><span class="p">)</span>

        <span class="n">pvals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fullPsf1d</span><span class="p">(</span><span class="n">star</span><span class="p">)[</span><span class="n">index1d</span><span class="p">]</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">star</span><span class="o">.</span><span class="n">fit</span><span class="o">.</span><span class="n">flux</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">coeffs</span><span class="o">*</span><span class="n">pvals</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">star</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">values_are_sb</span><span class="p">:</span>
            <span class="c1"># Change data from surface brightness into flux</span>
            <span class="n">model</span> <span class="o">*=</span> <span class="n">star</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">pixel_area</span>

        <span class="k">return</span> <span class="n">Star</span><span class="p">(</span><span class="n">star</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">setData</span><span class="p">(</span><span class="n">model</span><span class="p">,</span><span class="n">include_zero_weight</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span> <span class="n">star</span><span class="o">.</span><span class="n">fit</span><span class="p">)</span></div>

<div class="viewcode-block" id="PixelGrid.reflux"><a class="viewcode-back" href="../../model.html#piff.PixelGrid.reflux">[docs]</a>    <span class="k">def</span> <span class="nf">reflux</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">star</span><span class="p">,</span> <span class="n">fit_center</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Fit the Model to the star&#39;s data, varying only the flux (and</span>
<span class="sd">        center, if it is free).  Flux and center are updated in the Star&#39;s</span>
<span class="sd">        attributes.  This is a single-step solution if only solving for flux,</span>
<span class="sd">        otherwise an iterative operation.  DOF in the result assume</span>
<span class="sd">        only flux (&amp; center) are free parameters.</span>

<span class="sd">        :param star:        A Star instance</span>
<span class="sd">        :param fit_center:  If False, disable any motion of center</span>
<span class="sd">        :param logger:      A logger object for logging debug info. [default: None]</span>

<span class="sd">        :returns: a new Star instance, with updated flux, center, chisq, dof, worst</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span> <span class="o">=</span> <span class="n">galsim</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">LoggerWrapper</span><span class="p">(</span><span class="n">logger</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Reflux for star:&quot;</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;    flux = </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span><span class="n">star</span><span class="o">.</span><span class="n">fit</span><span class="o">.</span><span class="n">flux</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;    center = </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span><span class="n">star</span><span class="o">.</span><span class="n">fit</span><span class="o">.</span><span class="n">center</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;    props = </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span><span class="n">star</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">properties</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;    image = </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span><span class="n">star</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">image</span><span class="p">)</span>
        <span class="c1">#logger.debug(&quot;    image = %s&quot;,star.data.image.array)</span>
        <span class="c1">#logger.debug(&quot;    weight = %s&quot;,star.data.weight.array)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;    image center = </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span><span class="n">star</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">image</span><span class="p">(</span><span class="n">star</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">center</span><span class="p">))</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;    weight center = </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span><span class="n">star</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">weight</span><span class="p">(</span><span class="n">star</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">center</span><span class="p">))</span>

        <span class="c1"># This will be an iterative process if the centroid is free.</span>
        <span class="n">max_iterations</span> <span class="o">=</span> <span class="mi">100</span>    <span class="c1"># Max iteration count</span>

        <span class="n">chisq_thresh</span> <span class="o">=</span> <span class="mf">0.01</span>     <span class="c1"># Quit when reduced chisq changes less than this</span>
        <span class="n">do_center</span> <span class="o">=</span> <span class="n">fit_center</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_force_model_center</span>
        <span class="n">flux</span> <span class="o">=</span> <span class="n">star</span><span class="o">.</span><span class="n">fit</span><span class="o">.</span><span class="n">flux</span>
        <span class="n">center</span> <span class="o">=</span> <span class="n">star</span><span class="o">.</span><span class="n">fit</span><span class="o">.</span><span class="n">center</span>
        <span class="n">prev_chisq</span> <span class="o">=</span> <span class="mf">1.e500</span>
        <span class="k">for</span> <span class="n">iteration</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_iterations</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Start iteration </span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span><span class="n">iteration</span><span class="p">)</span>
            <span class="c1"># Start by getting all interpolation coefficients for all observed points</span>
            <span class="n">data</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">star</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">getDataVector</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">star</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">values_are_sb</span><span class="p">:</span>
                <span class="c1"># If the images are flux instead of surface brightness, convert</span>
                <span class="c1"># them into SB</span>
                <span class="n">star_pix_area</span> <span class="o">=</span> <span class="n">star</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">pixel_area</span>
                <span class="n">data</span> <span class="o">/=</span> <span class="n">star_pix_area</span>
                <span class="n">weight</span> <span class="o">*=</span> <span class="n">star_pix_area</span><span class="o">*</span><span class="n">star_pix_area</span>
            <span class="n">u</span> <span class="o">-=</span> <span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">v</span> <span class="o">-=</span> <span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">do_center</span><span class="p">:</span>
                <span class="n">coeffs</span><span class="p">,</span> <span class="n">dcdu</span><span class="p">,</span> <span class="n">dcdv</span><span class="p">,</span> <span class="n">psfx</span><span class="p">,</span> <span class="n">psfy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interp</span><span class="o">.</span><span class="n">derivatives</span><span class="p">(</span><span class="n">u</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">du</span><span class="p">,</span> <span class="n">v</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">du</span><span class="p">)</span>
                <span class="n">dcdu</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">du</span>
                <span class="n">dcdv</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">du</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">coeffs</span><span class="p">,</span> <span class="n">psfx</span><span class="p">,</span> <span class="n">psfy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">u</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">du</span><span class="p">,</span> <span class="n">v</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">du</span><span class="p">)</span>
            <span class="c1"># Turn the (psfy,psfx) coordinates into an index into 1d parameter vector.</span>
            <span class="n">index1d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indexFromPsfxy</span><span class="p">(</span><span class="n">psfx</span><span class="p">,</span> <span class="n">psfy</span><span class="p">)</span>
            <span class="c1"># All invalid pixel references now have negative index; record and set to zero</span>
            <span class="n">nopsf</span> <span class="o">=</span> <span class="n">index1d</span> <span class="o">&lt;</span> <span class="mi">0</span>
            <span class="n">index1d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">nopsf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">index1d</span><span class="p">)</span>
            <span class="c1"># And null the coefficients for such pixels</span>
            <span class="n">coeffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">nopsf</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">coeffs</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">do_center</span><span class="p">:</span>
                <span class="n">dcdu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">nopsf</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">dcdu</span><span class="p">)</span>
                <span class="n">dcdv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">nopsf</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">dcdv</span><span class="p">)</span>

            <span class="c1"># Multiply kernel (and derivs) by current PSF element values</span>
            <span class="c1"># to get current estimates</span>
            <span class="n">pvals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fullPsf1d</span><span class="p">(</span><span class="n">star</span><span class="p">)[</span><span class="n">index1d</span><span class="p">]</span>
            <span class="n">mod</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">coeffs</span><span class="o">*</span><span class="n">pvals</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">do_center</span><span class="p">:</span>
                <span class="n">dmdu</span> <span class="o">=</span> <span class="n">flux</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dcdu</span><span class="o">*</span><span class="n">pvals</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">dmdv</span> <span class="o">=</span> <span class="n">flux</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dcdv</span><span class="o">*</span><span class="n">pvals</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">derivs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span> <span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">dmdu</span><span class="p">,</span> <span class="n">dmdv</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">derivs</span> <span class="o">=</span> <span class="n">mod</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">mod</span><span class="o">.</span><span class="n">shape</span><span class="o">+</span><span class="p">(</span><span class="mi">1</span><span class="p">,))</span>
                <span class="c1"># derivs should end up with shape (npts, nconstraints)</span>
            <span class="n">resid</span> <span class="o">=</span> <span class="n">data</span> <span class="o">-</span> <span class="n">mod</span><span class="o">*</span><span class="n">flux</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;total pixels = </span><span class="si">%s</span><span class="s2">, nopsf = </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">pvals</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">nopsf</span><span class="p">))</span>

            <span class="c1"># Now begin construction of alpha/beta/chisq that give</span>
            <span class="c1"># chisq vs linearized model.</span>
            <span class="n">rw</span> <span class="o">=</span> <span class="n">resid</span> <span class="o">*</span> <span class="n">weight</span>
            <span class="n">chisq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">resid</span> <span class="o">*</span> <span class="n">rw</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;initial chisq = </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span><span class="n">chisq</span><span class="p">)</span>
            <span class="n">beta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">derivs</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">rw</span><span class="p">)</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">derivs</span><span class="o">.</span><span class="n">T</span><span class="o">*</span><span class="n">weight</span><span class="p">,</span> <span class="n">derivs</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">df</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">do_center</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Caught exception </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span><span class="n">e</span><span class="p">)</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Turning off centering and retrying&quot;</span><span class="p">)</span>
                    <span class="n">do_center</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span>
            <span class="n">dchi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">beta</span><span class="p">,</span> <span class="n">df</span><span class="p">)</span>
            <span class="n">chisq</span> <span class="o">=</span> <span class="n">chisq</span> <span class="o">-</span> <span class="n">dchi</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;chisq -= </span><span class="si">%s</span><span class="s2"> =&gt; </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span><span class="n">dchi</span><span class="p">,</span><span class="n">chisq</span><span class="p">)</span>
            <span class="c1"># Record worst single pixel chisq:</span>
            <span class="n">resid</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">derivs</span><span class="p">,</span><span class="n">df</span><span class="p">)</span>
            <span class="n">rw</span> <span class="o">=</span> <span class="n">resid</span> <span class="o">*</span> <span class="n">weight</span>
            <span class="n">worst_chisq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">resid</span> <span class="o">*</span> <span class="n">rw</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;worst_chisq = </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span><span class="n">worst_chisq</span><span class="p">)</span>

            <span class="c1"># update the flux (and center) of the star</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;initial flux = </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span><span class="n">flux</span><span class="p">)</span>
            <span class="n">flux</span> <span class="o">+=</span> <span class="n">df</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;flux += </span><span class="si">%s</span><span class="s2"> =&gt; </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span><span class="n">df</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">flux</span><span class="p">)</span>
            <span class="c1">###print(iteration,&#39;chisq&#39;,chisq,flux,center,df) ###</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;center = </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span><span class="n">center</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">do_center</span><span class="p">:</span>
                <span class="n">center</span> <span class="o">=</span> <span class="p">(</span><span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">df</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                          <span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">df</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;center += (</span><span class="si">%s</span><span class="s2">,</span><span class="si">%s</span><span class="s2">) =&gt; </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span><span class="n">df</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">df</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">center</span><span class="p">)</span>
            <span class="n">dof</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constraints</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;dchi, chisq_thresh, dof, do_center = </span><span class="si">%s</span><span class="s2">, </span><span class="si">%s</span><span class="s2">, </span><span class="si">%s</span><span class="s2">, </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
                         <span class="n">dchi</span><span class="p">,</span><span class="n">chisq_thresh</span><span class="p">,</span><span class="n">dof</span><span class="p">,</span><span class="n">do_center</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">dchi</span> <span class="o">&lt;</span> <span class="n">chisq_thresh</span> <span class="o">*</span> <span class="n">dof</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">do_center</span><span class="p">:</span>
                <span class="c1"># Done with iterations.  Return new Star with updated information</span>
                <span class="k">return</span> <span class="n">Star</span><span class="p">(</span><span class="n">star</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">StarFit</span><span class="p">(</span><span class="n">star</span><span class="o">.</span><span class="n">fit</span><span class="o">.</span><span class="n">params</span><span class="p">,</span>
                                               <span class="n">flux</span> <span class="o">=</span> <span class="n">flux</span><span class="p">,</span>
                                               <span class="n">center</span> <span class="o">=</span> <span class="n">center</span><span class="p">,</span>
                                               <span class="n">chisq</span> <span class="o">=</span> <span class="n">chisq</span><span class="p">,</span>
                                               <span class="n">worst_chisq</span> <span class="o">=</span> <span class="n">worst_chisq</span><span class="p">,</span>
                                               <span class="n">dof</span> <span class="o">=</span> <span class="n">dof</span><span class="p">,</span>
                                               <span class="n">alpha</span> <span class="o">=</span> <span class="n">star</span><span class="o">.</span><span class="n">fit</span><span class="o">.</span><span class="n">alpha</span><span class="p">,</span>
                                               <span class="n">beta</span> <span class="o">=</span> <span class="n">star</span><span class="o">.</span><span class="n">fit</span><span class="o">.</span><span class="n">beta</span><span class="p">))</span>
            <span class="c1"># If chisq went up, turn off centering.  There are a number of failure modes</span>
            <span class="c1"># to this algorithm that can lead to oscillatory behavior, so if we start doing</span>
            <span class="c1"># that, just turn off the centering for subsequent iterations.</span>
            <span class="k">if</span> <span class="n">chisq</span> <span class="o">&gt;</span> <span class="n">prev_chisq</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">do_center</span>  <span class="c1"># The logic of the above test means this should be True here.</span>
                <span class="n">do_center</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">center</span> <span class="o">=</span> <span class="p">(</span><span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">df</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">df</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>  <span class="c1"># undo the last centroid update.</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;chisq increased in reflux.  Turning off centering.&quot;</span><span class="p">)</span>
            <span class="n">prev_chisq</span> <span class="o">=</span> <span class="n">chisq</span>

        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Maximum number of iterations exceeded in PixelGrid.reflux()&quot;</span><span class="p">)</span></div></div>


<span class="k">class</span> <span class="nc">PixelInterpolant</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Interface for interpolators</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">range</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Size of interpolation kernel</span>

<span class="sd">        :returns: Maximum distance from target to source pixel.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Derived classes must define the range function&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate interpolation coefficient for vector of target points</span>

<span class="sd">        Outputs will be 3 matrices, each of dimensions (nin, nkernel) where nin is</span>
<span class="sd">        number of input coordinates and nkernel is number of points in kernel footprint.</span>
<span class="sd">        The coeff matrix gives interpolation coefficients, then the y and x integer matrices</span>
<span class="sd">        give the grid point to which each coefficient is applied.</span>

<span class="sd">        :param u: 1d array of target u coordinates</span>
<span class="sd">        :param v: 1d array of target v coordinates</span>

<span class="sd">        :returns: coeff, y, x</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Derived classes must define the __call__ function&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">derivatives</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate interpolation coefficient for vector of target points, and</span>
<span class="sd">        their derivatives with respect to shift in u, v position of the star.</span>

<span class="sd">        Outputs will be 5 matrices, each of dimensions (nin, nkernel) where nin is</span>
<span class="sd">        number of input coordinates and nkernel is number of points in kernel footprint.</span>
<span class="sd">        The coeff matrix gives interpolation coefficients; then there are derivatives of the</span>
<span class="sd">        kernel with respect to u and v; then the y and x integer matrices</span>
<span class="sd">        give the grid point to which each coefficient is applied.</span>

<span class="sd">        :param u: 1d array of target u coordinates</span>
<span class="sd">        :param v: 1d array of target v coordinates</span>

<span class="sd">        :returns: coeff, dcdu, dcdv, y, x</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Derived classes must define the derivatives function&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="Lanczos"><a class="viewcode-back" href="../../model.html#piff.Lanczos">[docs]</a><span class="k">class</span> <span class="nc">Lanczos</span><span class="p">(</span><span class="n">PixelInterpolant</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Lanczos interpolator in 2 dimensions.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize with the order of the filter</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="n">order</span>
        <span class="c1"># Here is range of pixels to use in each dimension relative to ceil(u,v)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_duv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="c1"># And here are flattened arrays of u, v displacement for whole footprint</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_du</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_duv</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_du</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_du</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span> <span class="o">*</span> \
          <span class="bp">self</span><span class="o">.</span><span class="n">_duv</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dv</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

<div class="viewcode-block" id="Lanczos.range"><a class="viewcode-back" href="../../model.html#piff.Lanczos.range">[docs]</a>    <span class="k">def</span> <span class="nf">range</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span></div>

    <span class="k">def</span> <span class="nf">_kernel1d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Calculate the 1d interpolation kernel at each value in array u.</span>

<span class="sd">        :param u: 1d array of (u_dest-u_src) spanning the footprint of the kernel.</span>

<span class="sd">        :returns: interpolation kernel values at these grid points</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Normalize Lanczos to unit sum over kernel elements</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sinc</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sinc</span><span class="p">(</span><span class="n">u</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">k</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">derivs</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<div class="viewcode-block" id="Lanczos.derivatives"><a class="viewcode-back" href="../../model.html#piff.Lanczos.derivatives">[docs]</a>    <span class="k">def</span> <span class="nf">derivatives</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">derivs</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_calculate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">derivs</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Routine which does the kernel calculations.  Uses finite differences to</span>
<span class="sd">        calculate derivatives, if requested.</span>

<span class="sd">        :param u,v:    1d arrays of coordinates to which we are interpolating</span>
<span class="sd">        :param derivs: Set to true if outputs should include derivatives w.r.t. u,v</span>

<span class="sd">        :returns: coeffs, [dcoeff/du, dcoeff/dv,] x, y where each is a 2d array of</span>
<span class="sd">        dimensions (len(u), # of kernel elements), holding coefficients of each grid point</span>
<span class="sd">        for interpolation to each destination point, [derivatives of these], and x,y are</span>
<span class="sd">        the integer coordinates of the grid points.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Get integer and fractional parts of u, v</span>
        <span class="n">u_ceil</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">v_ceil</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="c1"># Make arrays giving coordinates of grid points within footprint</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">u_ceil</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_du</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,:]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">v_ceil</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dv</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,:]</span>
        <span class="c1"># Make npts x (2*order) arrays holding 1d displacements</span>
        <span class="c1"># to be arguments of the 1d kernel functions</span>
        <span class="n">argu</span> <span class="o">=</span> <span class="p">(</span><span class="n">u_ceil</span><span class="o">-</span><span class="n">u</span><span class="p">)[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_duv</span>
        <span class="n">argv</span> <span class="o">=</span> <span class="p">(</span><span class="n">v_ceil</span><span class="o">-</span><span class="n">v</span><span class="p">)[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_duv</span>
        <span class="c1"># Calculate the Lanczos function each axis:</span>
        <span class="n">ku</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kernel1d</span><span class="p">(</span><span class="n">argu</span><span class="p">)</span>
        <span class="n">kv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kernel1d</span><span class="p">(</span><span class="n">argv</span><span class="p">)</span>
        <span class="c1"># Then take outer products to produce kernel</span>
        <span class="n">coeffs</span> <span class="o">=</span> <span class="p">(</span><span class="n">ku</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,:]</span> <span class="o">*</span> <span class="n">kv</span><span class="p">[:,:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">derivs</span><span class="p">:</span>
            <span class="c1"># Take derivatives with respect to u</span>
            <span class="n">duv</span> <span class="o">=</span> <span class="mf">0.01</span>   <span class="c1"># Step for finite differences</span>
            <span class="n">dku</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_kernel1d</span><span class="p">(</span><span class="n">argu</span><span class="o">+</span><span class="n">duv</span><span class="p">)</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_kernel1d</span><span class="p">(</span><span class="n">argu</span><span class="o">-</span><span class="n">duv</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">duv</span><span class="p">)</span>
            <span class="n">dcdu</span> <span class="o">=</span> <span class="p">(</span><span class="n">dku</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,:]</span> <span class="o">*</span> <span class="n">kv</span><span class="p">[:,:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="c1"># and v</span>
            <span class="n">dkv</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_kernel1d</span><span class="p">(</span><span class="n">argv</span><span class="o">+</span><span class="n">duv</span><span class="p">)</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_kernel1d</span><span class="p">(</span><span class="n">argv</span><span class="o">-</span><span class="n">duv</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">duv</span><span class="p">)</span>
            <span class="n">dcdv</span> <span class="o">=</span> <span class="p">(</span><span class="n">ku</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,:]</span> <span class="o">*</span> <span class="n">dkv</span><span class="p">[:,:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">coeffs</span><span class="p">,</span> <span class="n">dcdu</span><span class="p">,</span> <span class="n">dcdv</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">coeffs</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span></div>


<div class="viewcode-block" id="Bilinear"><a class="viewcode-back" href="../../model.html#piff.Bilinear">[docs]</a><span class="k">class</span> <span class="nc">Bilinear</span><span class="p">(</span><span class="n">PixelInterpolant</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Lanczos interpolator in 2 dimensions.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize - &quot;order&quot; is the range, 1 pixel here</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="c1"># Here is range of pixels to use in each dimension relative to ceil(u,v)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_duv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="c1"># And here are flattened arrays of u, v displacement for whole footprint</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_du</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_duv</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_du</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_du</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span> <span class="o">*</span> \
          <span class="bp">self</span><span class="o">.</span><span class="n">_duv</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dv</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

<div class="viewcode-block" id="Bilinear.range"><a class="viewcode-back" href="../../model.html#piff.Bilinear.range">[docs]</a>    <span class="k">def</span> <span class="nf">range</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span></div>

    <span class="k">def</span> <span class="nf">_kernel1d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Calculate the 1d interpolation kernel at each value in array u.</span>

<span class="sd">        :param u: 1d array of (u_dest-u_src) spanning the footprint of the kernel.</span>

<span class="sd">        :returns: interpolation kernel values at these grid points</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mf">1.</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">derivs</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<div class="viewcode-block" id="Bilinear.derivatives"><a class="viewcode-back" href="../../model.html#piff.Bilinear.derivatives">[docs]</a>    <span class="k">def</span> <span class="nf">derivatives</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">derivs</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_calculate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">derivs</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Routine which does the kernel calculations.  Uses finite differences to</span>
<span class="sd">        calculate derivatives, if requested.</span>

<span class="sd">        :param u,v:    1d arrays of coordinates to which we are interpolating</span>
<span class="sd">        :param derivs: Set to true if outputs should include derivatives w.r.t. u,v</span>

<span class="sd">        :returns: coeffs, [dcoeff/du, dcoeff/dv,] x, y where each is a 2d array of</span>
<span class="sd">        dimensions (len(u), # of kernel elements), holding coefficients of each grid point</span>
<span class="sd">        for interpolation to each destination point, [derivatives of these], and x,y are</span>
<span class="sd">        the integer coordinates of the grid points.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Get integer and fractional parts of u, v</span>
        <span class="n">u_ceil</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">v_ceil</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="c1"># Make arrays giving coordinates of grid points within footprint</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">u_ceil</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_du</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,:]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">v_ceil</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dv</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,:]</span>
        <span class="c1"># Make npts x (2*order) arrays holding 1d displacements</span>
        <span class="c1"># to be arguments of the 1d kernel functions</span>
        <span class="n">argu</span> <span class="o">=</span> <span class="p">(</span><span class="n">u_ceil</span><span class="o">-</span><span class="n">u</span><span class="p">)[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_duv</span>
        <span class="n">argv</span> <span class="o">=</span> <span class="p">(</span><span class="n">v_ceil</span><span class="o">-</span><span class="n">v</span><span class="p">)[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_duv</span>
        <span class="c1"># Calculate the 1d function each axis:</span>
        <span class="n">ku</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kernel1d</span><span class="p">(</span><span class="n">argu</span><span class="p">)</span>
        <span class="n">kv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kernel1d</span><span class="p">(</span><span class="n">argv</span><span class="p">)</span>
        <span class="c1"># Then take outer products to produce kernel</span>
        <span class="n">coeffs</span> <span class="o">=</span> <span class="p">(</span><span class="n">ku</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,:]</span> <span class="o">*</span> <span class="n">kv</span><span class="p">[:,:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">derivs</span><span class="p">:</span>
            <span class="c1"># Take derivatives with respect to u</span>
            <span class="n">duv</span> <span class="o">=</span> <span class="mf">0.01</span>   <span class="c1"># Step for finite differences</span>
            <span class="n">dku</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_kernel1d</span><span class="p">(</span><span class="n">argu</span><span class="o">+</span><span class="n">duv</span><span class="p">)</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_kernel1d</span><span class="p">(</span><span class="n">argu</span><span class="o">-</span><span class="n">duv</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">duv</span><span class="p">)</span>
            <span class="n">dcdu</span> <span class="o">=</span> <span class="p">(</span><span class="n">dku</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,:]</span> <span class="o">*</span> <span class="n">kv</span><span class="p">[:,:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="c1"># and v</span>
            <span class="n">dkv</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_kernel1d</span><span class="p">(</span><span class="n">argv</span><span class="o">+</span><span class="n">duv</span><span class="p">)</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_kernel1d</span><span class="p">(</span><span class="n">argv</span><span class="o">-</span><span class="n">duv</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">duv</span><span class="p">)</span>
            <span class="n">dcdv</span> <span class="o">=</span> <span class="p">(</span><span class="n">ku</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,:]</span> <span class="o">*</span> <span class="n">dkv</span><span class="p">[:,:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">coeffs</span><span class="p">,</span> <span class="n">dcdu</span><span class="p">,</span> <span class="n">dcdv</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">coeffs</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="nav-item nav-item-0"><a href="../../index.html">Piff 0.2.4 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016, Mike Jarvis and the other collaborators at https://github.com/rmjarvis/Piff.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.3.
    </div>
  </body>
</html>